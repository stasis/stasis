#! /usr/bin/perl -w 
use strict;

sub jfdi { 

    my $bn_ref = shift;
    my $exe_ref = shift;
    my $complete_output = shift;
    my $eval_x = shift;
    my $eval_y = shift;
#    if(-e $complete_output) { 
#	warn "$complete_output exists--skipping\n";
#	return;
#    }

    my @baseNames = @{$bn_ref};
    my @exeNames = @{$exe_ref};

    my $exec = "mkdir $complete_output\n";
    print  $exec;
    `$exec`;
    $exec = "ln -s ../$complete_output.def $complete_output/\n";
    print $exec;
    `$exec`;
    
    for(my $i =0 ; $i < @baseNames; $i++) {
	$exec = "grep CI $complete_output.out | grep $exeNames[$i] | ci-parser.pl --force '$eval_x' '$eval_y' > $complete_output/$complete_output-$baseNames[$i].dat\n";
	print $exec;
	`$exec`;
    }
    `cd $complete_output ; plotting.pl $complete_output | R --no-save ; cd ..`
}
    


# parse the output generated by timer.pl when is it run using generateScripts.pl's output 

my @baseNames = qw(LLADD_NTA_HASH         LLADD_FAST_HASH  BDB_HASH );
my @exeNames  = qw(linearHashNTAThreaded  logicalHash      bdbHashThreaded);
my $complete_output = "BULK_LOAD";
jfdi(\@baseNames, \@exeNames, $complete_output, '$arg[1]', '$time');

@baseNames = qw(LLADD_ARRAY_LIST LLADD_LINKED_LIST LLADD_RECORDID BDB_RAW);
@exeNames  = qw(arrayListSet     pageOrientedList  rawSet         bdbHashThreaded);
$complete_output = "BULK_LOAD_RAW";
jfdi(\@baseNames, \@exeNames, $complete_output, '$arg[1]', '$time');

@baseNames = qw(LLADD_HASH_TPS              BDB_HASH_TPS);
@exeNames  = qw(linearHashNTAThreaded       bdbHashThreaded);
$complete_output = "TPS";
jfdi(\@baseNames, \@exeNames, $complete_output, '$arg[0]',  '($arg[0]*$arg[1])/$time');

@baseNames = qw(LLADD_HASH_TPS);
@exeNames  = qw(linearHashNTAThreaded);
$complete_output = "LLADD_HASH_TPS";
jfdi(\@baseNames, \@exeNames, $complete_output, '$arg[0]',  '($arg[0]*$arg[1])/$time');

